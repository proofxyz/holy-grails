import { exiftool } from 'exiftool-vendored';
import path from 'path';
import { exit } from 'process';
import { v4 as uuid } from 'uuid';

import {
  CLEAN_DIR,
  DEBUG_MODE,
  EXIFTOOL_SUFFIX,
  PROCESSED_DIR,
  PROCESSING_DIR,
  SOURCE_DIR,
} from './constants.mjs';
import { copy, makeDir, move, remove, traverse } from './src/file.mjs';
import { log } from './src/log.mjs';
import { discoveredUnwritableTags, unwritableTags } from './src/tags.mjs';

// Version
const version = await exiftool.version();
log('üèÜ', `Holy Grails is running ExifTool v${version}`);

if (DEBUG_MODE) {
  log('üêõ', 'Debug mode enabled.');
}

const files = await traverse(SOURCE_DIR);
log('ü§ì', `Reading ${files.length} files from ${SOURCE_DIR}‚Ä¶`);

for (let i = 0, n = files.length; i < n; i += 1) {
  // Original file info
  const sourceFile = files[i];
  const pathRelativeToSourceDirectory = path.relative(SOURCE_DIR, sourceFile);
  const sourceDir = path.dirname(pathRelativeToSourceDirectory);
  const sourceExt = path.extname(sourceFile);
  const sourceName = path.basename(sourceFile, sourceExt);

  // The processing file is a temporary copy of the source file, used during
  // processing and removed afterward.
  const processingFile = path.format({
    dir: PROCESSING_DIR,
    name: uuid(),
    ext: sourceExt,
  });

  // The backup file is generated by ExifTool. It is stored adjacent to the
  // processing file.
  const backupFile = `${processingFile}${EXIFTOOL_SUFFIX}`;

  // The clean file is the asset without its original metadata.
  const cleanFile = path.format({
    dir: path.join(CLEAN_DIR, sourceDir),
    name: sourceName,
    ext: sourceExt,
  });

  // The processed file is the source file moved to a new directory. This allows
  // us to track completed files and re-run the script efficiently, without
  // re-processing successfully processed files.
  const processedFile = path.format({
    dir: path.join(PROCESSED_DIR, sourceDir),
    name: uuid(),
    ext: sourceExt,
  });

  // Begin!
  log('üñº ', pathRelativeToSourceDirectory);

  // Copy source file to a temporary processing directory.
  await makeDir(path.dirname(processingFile));
  await copy(sourceFile, processingFile);

  // Extract tags from file.
  const tags = await exiftool.read(processingFile);
  const entries = Object.entries(tags);

  if (DEBUG_MODE) {
    entries.forEach(([key, value]) => {
      log('üîç', `${key}: ${value}`);
    });
  }

  // Attempt to remove tags, one at a time.
  // TODO check to see if we can delete all tags at once.
  for (const [key] of entries) {
    // Skip unwritable tags.
    if (unwritableTags.has(key)) continue;

    try {
      await exiftool.write(processingFile, { [key]: null });
      log('üü¢', `Removed ${key}`);
    } catch (error) {
      log('‚õîÔ∏è', `Unable to remove ${key}`);
      unwritableTags.add(key);
      discoveredUnwritableTags.add(key);
    }
  }

  // Remove backup file.
  await remove(backupFile);

  // Move processed file to clean directory.
  await makeDir(path.dirname(cleanFile));
  await move(processingFile, cleanFile);

  // Move source file to processed directory.
  await makeDir(path.dirname(processedFile));
  await move(sourceFile, processedFile);

  // Report status
  const remaining = files.length - i - 1;
  if (remaining > 0) {
    log('üí™', `${remaining}/${files.length} files remaining‚Ä¶`);
  } else {
    log('üôå', 'Done!');
  }
}

// Log discovered unwritable tags so that they can be added to tags.txt.
if (discoveredUnwritableTags.size > 0) {
  const newTags = Array.from(discoveredUnwritableTags);
  log('üö´', `Discovered new unwritable tags: ${newTags.join(', ')}`);
}

exit(0);
